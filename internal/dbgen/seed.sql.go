// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: seed.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

const getAllSeedTranslations = `-- name: GetAllSeedTranslations :many
SELECT hash, source_text, translated_text, file, function_name, entity_type
FROM seed_translations
WHERE is_seed = TRUE
ORDER BY created_at
`

type GetAllSeedTranslationsRow struct {
	Hash           string `json:"hash"`
	SourceText     string `json:"source_text"`
	TranslatedText string `json:"translated_text"`
	File           string `json:"file"`
	FunctionName   string `json:"function_name"`
	EntityType     string `json:"entity_type"`
}

func (q *Queries) GetAllSeedTranslations(ctx context.Context) ([]GetAllSeedTranslationsRow, error) {
	rows, err := q.db.Query(ctx, getAllSeedTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSeedTranslationsRow{}
	for rows.Next() {
		var i GetAllSeedTranslationsRow
		if err := rows.Scan(
			&i.Hash,
			&i.SourceText,
			&i.TranslatedText,
			&i.File,
			&i.FunctionName,
			&i.EntityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeedTranslationsByEntityType = `-- name: GetSeedTranslationsByEntityType :many
SELECT hash, source_text, translated_text, file, function_name, entity_type
FROM seed_translations
WHERE is_seed = TRUE AND entity_type = $1
ORDER BY created_at
`

type GetSeedTranslationsByEntityTypeRow struct {
	Hash           string `json:"hash"`
	SourceText     string `json:"source_text"`
	TranslatedText string `json:"translated_text"`
	File           string `json:"file"`
	FunctionName   string `json:"function_name"`
	EntityType     string `json:"entity_type"`
}

func (q *Queries) GetSeedTranslationsByEntityType(ctx context.Context, entityType string) ([]GetSeedTranslationsByEntityTypeRow, error) {
	rows, err := q.db.Query(ctx, getSeedTranslationsByEntityType, entityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeedTranslationsByEntityTypeRow{}
	for rows.Next() {
		var i GetSeedTranslationsByEntityTypeRow
		if err := rows.Scan(
			&i.Hash,
			&i.SourceText,
			&i.TranslatedText,
			&i.File,
			&i.FunctionName,
			&i.EntityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSeedTranslation = `-- name: UpsertSeedTranslation :execresult
INSERT INTO seed_translations (hash, source_text, translated_text, file, function_name, entity_type)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (hash) DO UPDATE SET
    translated_text = EXCLUDED.translated_text,
    file = EXCLUDED.file,
    function_name = EXCLUDED.function_name,
    entity_type = EXCLUDED.entity_type,
    updated_at = NOW()
`

type UpsertSeedTranslationParams struct {
	Hash           string `json:"hash"`
	SourceText     string `json:"source_text"`
	TranslatedText string `json:"translated_text"`
	File           string `json:"file"`
	FunctionName   string `json:"function_name"`
	EntityType     string `json:"entity_type"`
}

func (q *Queries) UpsertSeedTranslation(ctx context.Context, arg UpsertSeedTranslationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, upsertSeedTranslation,
		arg.Hash,
		arg.SourceText,
		arg.TranslatedText,
		arg.File,
		arg.FunctionName,
		arg.EntityType,
	)
}
